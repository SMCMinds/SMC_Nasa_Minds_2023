from robot_class import robot
from math import *
from matplotlib import animation
import random
import seaborn as sns
from pandas import DataFrame
import matplotlib.pyplot as plt
import numpy as np
from helpers import make_data, display_world

###########CHANGES NEEDED####################
'''
So, this algorithm depends on predetermined landmarks that are randomly generated in the world. 
Thus, modification is needed. 

Curr: modify code so it does not rely on  N and make the animation functional

1) The make_landmarks function needs to change because it randomly generates in the map

2) Is noise really necessary in our algorithm?

3) make_data needs to be changed since it is the function that moves the robot
and creates the data

4) transform make_data into something that is gathered constantly in this file

5) use a while loop from previous code to track the data and use the data in real time

6) Find out how sensors can be used to find landmarks

6) Graphing can be figured out while working on the while loop since it gets help from
the display function in the helper file

7) Replace the get_pose_landmark which changes the numpy array to python array

'''


def initialize_constraints(N, num_landmarks, world_size):
    ''' This function takes in a number of time steps N, number of landmarks, and a world_size,
        and returns initialized constraint matrices, omega and xi.'''

    ###########CHANGE###############
    #size dependent on predetermined number of landmarks
    size = (N + num_landmarks)*2
    ################################
    rows = size
    cols = size

    # TODO: Define the constraint matrix, Omega, with two initial "strength" values
    # for the initial x, y location of our robot
    omega = np.zeros((rows, cols))

    strength = 1

    mid = world_size / 2
    initial_x = mid
    initial_y = mid

    omega[0, 0] = strength
    omega[1, 1] = strength
    # TODO: Define the constraint *vector*, xi
    # you can assume that the robot starts out in the middle of the world with 100% confidence
    xi = np.zeros((rows, 1))
    xi[0] = initial_x
    xi[1] = initial_y
    return omega, xi


# world parameters
landmarks = []
num_landmarks = 6
N = 20       # time steps
world_size = 100.0    # size of world (square)

# make_landmarks:
# # make random landmarks located in the world
def make_landmarks(num_landmarks):
    #for random obstacles
    # for i in range(num_landmarks):
    #     landmarks.append([round(random.random() * world_size),round(random.random() * world_size)])
    
    #for a wall
    for i in range(world_size/5):
        horizontal_coor = round(random.random() * world_size)
        landmarks.append([horizontal_coor, i])
    
    
    return landmarks

# robot parameters
measurement_range = 50.0     # range at which we can sense landmarks
motion_noise = 2.0      # noise in robot motion
measurement_noise = 2.0      # noise in the measurements
# distance by which robot (intends to) move each iteratation
distance = 20.0

#Initiate robot class
landmarks = make_landmarks(num_landmarks)
r = robot(world_size, measurement_range, landmarks)

# make_data instantiates a robot, AND generates random landmarks for a given world size and number of landmarks
##Got rid of N, so just make sure to loop it correctly
data = make_data(r, landmarks,world_size, measurement_range,
                 motion_noise, measurement_noise, distance)

time_step = 0

## mu is the entire path traversed by a robot (all x,y poses) *and* all landmarks locations
## since xi is motion with error and omega is obstacle detection error
## xi = mu*omega
##  mu is the probable true path through noise calculation
'''Seems to overcomplicate a little? But I'll stick with it since it seems like 
something to try''' 
def slam(data, N, num_landmarks, world_size, motion_noise, measurement_noise):
    
    ## TODO: Use your initilization to create constraint matrices, omega and xi
    omega, xi = initialize_constraints(N, num_landmarks, world_size)
    
    ## TODO: Iterate through each time step in the data
    ## get all the motion and measurement data as you iterate
    
    '''Adds the uncertainty in the collection of data in the robot's position
    and the landmarks'''
    for i in range(len(data)):
        measurements = data[i][0]
        motion = data[i][1]
    
        ## TODO: update the constraint matrix/vector to account for all *measurements*
        ## this should be a series of additions that take into account the measurement noise
        nweight = 1 / measurement_noise
        for m in measurements:
            landmark = m[0]
            x = m[1]
            y=  m[2]
            
            omega[2*i, 2*i] += nweight
            omega[2*i, 2*N + 2*landmark] -= nweight #used to be += -nweight if it doesnt work
            omega[2*N + 2*landmark, 2*i] -= nweight
            omega[2*N + 2*landmark, 2*N + 2*landmark] += nweight 

            xi[2*i, 0] -= x *nweight
            xi[2*N + 2*landmark, 0] += x *nweight
            
            omega[2*i + 1, 2*i + 1] += nweight
            omega[2*i + 1, 2*N + 2*landmark + 1] += -nweight
            omega[2*N + 2*landmark + 1, 2*i + 1] += -nweight
            omega[2*N + 2*landmark + 1, 2*N + 2*landmark + 1] += nweight
            xi[2*i + 1, 0] += -y *nweight
            xi[2*N + 2*landmark + 1, 0] += y *nweight  
            
     ## TODO: update the constraint matrix/vector to account for all *motion* and motion noise       
        dx = motion[0]             
        dy = motion[1]
        mweight = 1 / motion_noise
    
        omega[2*i, 2*i] +=  mweight
        omega[2*i, 2*i + 2] += - mweight
        omega[2*i + 2, 2*i] += - mweight
        omega[2*i + 2, 2*i + 2] += mweight
        
        xi[2*i, 0] += -dx  * mweight             
        xi[2*i + 2, 0] += dx * mweight   
        
  
        omega[2*i + 1, 2*i + 1] += mweight
        omega[2*i + 1, 2*i + 3] += - mweight
        omega[2*i + 3, 2*i + 1] += - mweight
        omega[2*i + 3, 2*i + 3] += mweight 
        
        xi[2*i + 1, 0] += -dy * mweight
        xi[2*i + 3, 0] += dy * mweight
        
        
    ## TODO: After iterating through all the data
    ## Compute the best estimate of poses and landmark positions
    ## using the formula, omega_inverse * Xi
    mu = np.linalg.inv(np.matrix(omega)) * xi
    return mu # return `mu`


# a helper function that creates a list of poses and of landmarks for ease of printing
# this only works for the suggested constraint architecture of interlaced x,y poses

#converts numpy array into python array
'''def get_poses_landmarks(mu, N):
    # create a list of poses
    poses = []
    for i in range(N):
        poses.append((mu[2*i].item(), mu[2*i+1].item()))

    # create a list of landmarks
    landmarks = []
    for i in range(num_landmarks):
        landmarks.append((mu[2*(N+i)].item(), mu[2*(N+i)+1].item()))

    # return completed lists
    return poses, landmarks
    
    #prints all the coordinates that the robot makes
def print_all(poses, landmarks):
    print('\n')
    print('Estimated Poses:')
    for i in range(len(poses)):
        print('['+', '.join('%.3f' % p for p in poses[i])+']')
    print('\n')
    print('Estimated Landmarks:')
    for i in range(len(landmarks)):
        print('['+', '.join('%.3f' % l for l in landmarks[i])+']')
    
    '''

#converts numpy value into python value
def get_pose_landmark(mu, i , np_landmarks):
    # create a list of poses
    landmarks = []
    for j in range(len(np_landmarks)):
        landmarks.append((mu[2*(i+j)].item(), mu[2*(i+j)+1].item()))
    # return pose, landmark array
    return (mu[2*i].item(), mu[2*i+1].item()), landmarks

#prints all the coordinates that the robot makes
def print_all(poses, landmarks):
    print('\n')
    print('Estimated Poses:')
    print('['+', '.join(poses)+']')
    print('\n')
    print('Estimated Landmarks:')
    for i in range(len(landmarks)):
        print('['+', '.join('%.3f' % l for l in landmarks[i])+']')



# call your implementation of slam, passing in the necessary parameters
mu = slam(data, N, num_landmarks, world_size, motion_noise, measurement_noise)

pose, landmarks = get_pose_landmark(mu, frame_number, r.landmarks)

# import the helper function

# Display the final world!

# define figure size
# it determines the size of the window that opens
plt.rcParams["figure.figsize"] = (20, 20)


#Do I even need to animate the graph?
'''
def animate(frame_number):
    global ax  # need it to remove old plot

    # print('frame_number:', frame_number)
    
    # get latest pose and all landmarks
    

    
    # Create an 'o' character that represents the robot
    # ha = horizontal alignment, va = vertical
    ax.text(pose[frame_number][0], pose[frame_number][1], 'o', ha='center', va='center', color='r', fontsize=30)
    
    # Draw landmarks if they exists
    if(landmarks is not None):
        # loop through all path indices and draw a dot (unless it's at the car's location)
        for pos in landmarks:
            if(pos != pose[frame_number]):
                ax.text(pos[0], pos[1], 'x', ha='center', va='center', color='purple', fontsize=20)
    
    # Display final result
    plt.show()

    # move all particles
    r.move()

    # after for-loop

    # remove old plot
    #d.set_data([], [])
    fig.remove()

    # create new plot
    # d, = plt.plot([particle.x for particle in pop], [
    #               particle.y for particle in pop], 'go')
    '''


# --- main ---
fig = plt.figure(1)

# using seaborn, set background grid to gray
sns.set_style("dark")

# Plot grid of values
world_grid = np.zeros((world_size+1, world_size+1))

# Set minor axes in between the labels
#gca, gets current axis
ax=plt.gca()
cols = world_size+1
rows = world_size+1

ax.set_xticks([x for x in range(1,cols)],minor=True )
ax.set_yticks([y for y in range(1,rows)],minor=True)

# Plot grid on minor axes in gray (width = 1)
plt.grid(which='minor',ls='-',lw=1, color='white')

# Plot grid on major axes in larger width
plt.grid(which='major',ls='-',lw=2, color='white')

# fig = plt.gcf()
# draw first plot
# d,  = plt.plot([particle.x for particle in pop], [
#                particle.y for particle in pop], 'go')
# anim = animation.FuncAnimation(fig, animate, frames=200, interval=45, repeat=False)

plt.show()